////////////////////////////////////////////////////////////////////////
// Class:       supernova
// Module Type: analyzer
// File:        supernova_module.cc
//
// Generated at Thu Jun  3 11:42:56 2021 by Ivan Lepetic using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "art_root_io/TFileService.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardataobj/RawData/raw.h"
#include "canvas/Persistency/Provenance/EventAuxiliary.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"

#include "larcore/Geometry/Geometry.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"

#include "TTree.h"

class supernova;

class supernova : public art::EDAnalyzer {
public:
  explicit supernova(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  supernova(supernova const &) = delete;
  supernova(supernova &&) = delete;
  supernova & operator = (supernova const &) = delete;
  supernova & operator = (supernova &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p);
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:


  typedef art::Handle<std::vector<simb::MCParticle>> MCParticleHandle;
  std::string m_particle_producer;
  std::string m_mcparticle_producer;
  // Declare member data here.

  TTree *fEventTree;
  uint fRun, fSubrun, fEvent;

  // MC info
    UInt_t fNumMCParticles = 0;
    std::vector<Int_t> fTrackId;
    std::vector<Int_t> fMother;
    std::vector<Int_t> fNumberDaughters;
    std::vector<Int_t> fpdg;
    std::vector<double> fEng;
    std::vector<double> fStartPointx;
    std::vector<double> fStartPointy;
    std::vector<double> fStartPointz;
    std::vector<double> fEndPointx;
    std::vector<double> fEndPointy;
    std::vector<double> fEndPointz;
    std::vector<double> fTrueWire;
    std::vector<double> fTrueTime;
    std::vector<double> fTime;
    std::vector<double> fPx;
    std::vector<double> fPy;
    std::vector<double> fPz;
    std::vector<std::string> fprocess;

};


supernova::supernova(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{

  art::ServiceHandle<art::TFileService> tfs;
      this->reconfigure(p);

      //// Check if things are set up properly:
      std::cout << std::endl;
      std::cout << "[DecayFinder constructor] Checking set-up" << std::endl;
      std::cout << "[DecayFinder constructor] m_particle_producer: " << m_particle_producer << std::endl;
      std::cout << "[DecayFinder constructor] m_mcparticle_producer: " << m_mcparticle_producer << std::endl;

      //// Tree for every event
      fEventTree = tfs->make<TTree>("Event", "Event Tree");
      fEventTree->Branch("event", &fEvent, "event/i");
      fEventTree->Branch("run", &fRun, "run/i");
      fEventTree->Branch("subrun", &fSubrun, "subrun/i");

          fEventTree->Branch("TrackId", "std::vector<Int_t>", &fTrackId);
          fEventTree->Branch("Mother", "std::vector<Int_t>", &fMother);
          fEventTree->Branch("NumberDaughters", "std::vector<Int_t>", &fNumberDaughters);
          fEventTree->Branch("pdg", "std::vector<Int_t>", &fpdg);
          fEventTree->Branch("Eng", "std::vector<double>", &fEng);
          fEventTree->Branch("StartPointx", "std::vector<double>", &fStartPointx);
          fEventTree->Branch("StartPointy", "std::vector<double>", &fStartPointy);
          fEventTree->Branch("StartPointz", "std::vector<double>", &fStartPointz);
          fEventTree->Branch("EndPointx", "std::vector<double>", &fEndPointx);
          fEventTree->Branch("EndPointy", "std::vector<double>", &fEndPointy);
          fEventTree->Branch("EndPointz", "std::vector<double>", &fEndPointz);
          fEventTree->Branch("TrueWire", "std::vector<double>", &fTrueWire);
          fEventTree->Branch("TrueTime", "std::vector<double>", &fTrueTime);
          fEventTree->Branch("Time", "std::vector<double>", &fTime);
          fEventTree->Branch("Px", "std::vector<double>", &fPx);
          fEventTree->Branch("Py", "std::vector<double>", &fPy);
          fEventTree->Branch("Pz", "std::vector<double>", &fPz);
          fEventTree->Branch("process", "std::vector<std::string>", &fprocess);

}

void supernova::analyze(art::Event const & e)
{

      fNumMCParticles = 0;
      fTrackId.clear();
      fMother.clear();
      fNumberDaughters.clear();
      fpdg.clear();
      fEng.clear();
      fStartPointx.clear();
      fStartPointy.clear();
      fStartPointz.clear();
      fEndPointx.clear();
      fEndPointy.clear();
      fEndPointz.clear();
      fTrueWire.clear();
      fTrueTime.clear();
      fPx.clear();
      fPy.clear();
      fPz.clear();

  // Implementation of required member function here.



    fEventTree->Fill();

}

void supernova::beginJob()
{
  // Implementation of optional member function here.
}

void supernova::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void supernova::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void supernova::endJob()
{
  // Implementation of optional member function here.
}

void supernova::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void supernova::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void supernova::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  m_mcparticle_producer = p.get<std::string>("mcparticle_producer", "largeant");

}

void supernova::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void supernova::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void supernova::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void supernova::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(supernova)
